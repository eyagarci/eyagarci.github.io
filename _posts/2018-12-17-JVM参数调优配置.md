---
layout: post
title: JVM参数调优配置
date: 2018-12-17
tags: java
---



# JVM参数调优配置

## Java内存结构

java内存结构（JVM虚拟机的一个存储空间）------两者很大的区别------java内存模型（多线程JMM，线程可见性）

### 方法区（永久区）：

static修饰 、 常量信息 ，在class文件被加载的时候就初始化。所有线程都是共享的。注意线程安全问题。

#### 调优问题：web开发过程中，定义常量太多好不好？

答：肯定是不好的，因为常量定义太多，就都存储在方法区里，java的垃圾回收机制就会自动略过方法区，非常占内存，会造成内存溢出问题，并且方法区是所有线程都是共享的，容易产生线程安全问题。

### 栈

定义基本局部变量，类的方法，栈代码运行完毕，自动释放内存。每个线程私有，互不共享，不会产生线程安全问题。

### 堆

创建对象，new，数组都会存放在堆内存中，调优策略主要还是对堆操作，堆是被所有线程共享的。堆内存有分两个区：新生代，老年代（垃圾回收机制）

![ss](https://ripperhxy.github.io\images\blog\jvm\dui.png)

#### 新生代

eden、s0、s1：刚出创建的对象，先放在新生代，s0和s1大小相当，目的是垃圾回收机制复制算法

#### 老年代

如果创建的对象还在s0、s1频繁使用，就会存放在老年代

##### 问题：垃圾回收机制需要经常去老年代吗？

答：垃圾回收机制经常去新生代，因为经常使用后，到了老年代的是已经是很成熟，经常被使用的对象，都在使用的对象干嘛要去回收。

### 本地方法栈

主要调用C语言的，运用技术JNI，用java语言去调用C语言

### PC寄存器

线程私有，不共享，计算机组成原理，操作指针，计算机变量的指令

### 执行引擎

执行字节码文件

### 垃圾回收机制

不定时回收堆内存空间资源

## JVM调优：

-XX:+PrintGC      每次触发GC的时候打印相关日志

-XX:+UseSerialGC      串行回收

-XX:+PrintGCDetails  更详细的GC日志

-Xms               堆初始值

-Xmx               堆最大可用值

-Xmn               新生代堆最大可用值

-XX:SurvivorRatio     用来设置新生代中eden空间和from/to空间的比例.

*-XX:NewRatio=****老年代/新生代**

**含以-XX:SurvivorRatio=eden/from=den/to**

**总结:在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，**

**这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。**

-XX:SurvivorRatio     用来设置新生代中eden空间和from/to空间的比例.

1、在web系统中，尽量减少常量信息的定义，

2、回收新生代的次数比老年代多：设置新生代与老年代回收比例（1/3或者1/4）

```
参数: -Xms20m -Xmx20m -Xmn1m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC
-Xms20m -Xmx20m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC -XX:NewRatio=2
```

3、减少垃圾回收机制次数（堆初始值和堆内存最大值一定要保持一致，初始值越小，垃圾回收机制次数越多，垃圾频繁回收影响效率）。

```
设置最大堆内存
参数: -Xms20m -Xmx20m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:+PrintCommandLineFlags
```

4、堆内存溢出问题：把最大堆内存值设置合理设置大一点（例如，运行需要10m 堆内存最大值30~40M）

最大值设置就不说了，上面有

tomcat

```
JAVA_OPTS="-server -Xms800m -Xmx800m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxNewSize=512m"
```

5、栈溢出：就是在方法中无限递归调用方法，不是循环调用方法。

```
-Xss5m 设置最大调用深度
```

---

### JVM参数调优总结

​    在JVM启动参数中，可以设置跟内存、垃圾回收相关的一些参数设置，默认情况不做任何设置JVM会工作的很好，但对一些配置很好的Server和具体的应用必须仔细调优才能获得最佳性能。通过设置我们希望达到一些目标：

·         GC的时间足够的小

·         GC的次数足够的少

·         发生Full GC(新生代和老年代)的周期足够的长

  前两个目前是相悖的，要想GC时间小必须要一个更小的堆，要保证GC次数足够少，必须保证一个更大的堆，我们只能取其平衡。

   **（1）针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，我们通常把最大、最小设置为相同的值**    **（2）年轻代和年老代将根据默认的比例（1：2）分配堆内存，可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代，比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小**

   （3）年轻代和年老代设置多大才算合理？这个我问题毫无疑问是没有答案的，否则也就不会有调优。我们观察一下二者大小变化有哪些影响
